-- blocking_stats.sql.j2
-- Params:
--   source_table      : e.g. silver.companies
--   target_schema     : e.g. er
--   id_col            : 'company_id'
--   name_col          : 'company_name'
--   domain_col        : 'domain_name'
--   city_col          : 'city'
--   country_col       : 'final_country'
--   max_block_size    : e.g. 1000
--   use_domain        : true/false
--   use_name3_country : true/false
--   use_compact5_city : true/false
--   pairs_table       : optional fully-qualified pairs table (e.g. er.blocking_pairs)

CREATE SCHEMA IF NOT EXISTS {{ target_schema }};

WITH base AS (
  SELECT
    {{ id_col }}::BIGINT                       AS company_id,
    NULLIF(LOWER(TRIM({{ domain_col }})), '')  AS domain_name,
    LOWER({{ name_col }})                      AS name_lower,
    REGEXP_REPLACE(LOWER({{ name_col }}), '[^a-z0-9\s]', '', 'g') AS name_alnum,
    REGEXP_REPLACE(REGEXP_REPLACE(LOWER({{ name_col }}), '[^a-z0-9\s]', '', 'g'), '\s', '', 'g') AS name_compact,
    NULLIF(LOWER(TRIM({{ city_col }})), '')    AS city,
    NULLIF(LOWER(TRIM({{ country_col }})), '') AS country
  FROM {{ source_table }}
),

blocks AS (
  {% set first = true %}

  {% if use_domain %}
  SELECT company_id, 'domain' AS kind, domain_name AS bkey
  FROM base
  WHERE domain_name IS NOT NULL
  {% set first = false %}
  {% endif %}

  {% if use_name3_country %}
  {% if not first %} UNION ALL {% endif %}
  SELECT company_id, 'name3_country' AS kind,
         CONCAT(SUBSTR(name_compact, 1, 3), '|', country) AS bkey
  FROM base
  WHERE name_compact IS NOT NULL AND country IS NOT NULL AND LENGTH(name_compact) >= 3
  {% set first = false %}
  {% endif %}

  {% if use_compact5_city %}
  {% if not first %} UNION ALL {% endif %}
  SELECT company_id, 'compact5_city' AS kind,
         CONCAT(SUBSTR(name_compact, 1, 5), '|', city) AS bkey
  FROM base
  WHERE name_compact IS NOT NULL AND city IS NOT NULL AND LENGTH(name_compact) >= 5
  {% endif %}
),

block_sizes AS (
  SELECT kind, bkey, COUNT(*)::BIGINT AS n
  FROM blocks
  GROUP BY kind, bkey
),

kept_blocks AS (
  SELECT * FROM block_sizes WHERE n BETWEEN 2 AND {{ max_block_size }}
),

dropped_small AS (
  SELECT * FROM block_sizes WHERE n < 2
),

dropped_large AS (
  SELECT * FROM block_sizes WHERE n > {{ max_block_size }}
),

-- estimate pair count from kept blocks: n*(n-1)/2
pair_estimates AS (
  SELECT kind, SUM((n * (n - 1)) / 2)::BIGINT AS est_pairs
  FROM kept_blocks
  GROUP BY kind
),

overall AS (
  SELECT
    (SELECT COUNT(*) FROM block_sizes)          AS total_blocks,
    (SELECT COUNT(*) FROM kept_blocks)          AS kept_blocks,
    (SELECT COUNT(*) FROM dropped_small)        AS dropped_small_blocks,
    (SELECT COUNT(*) FROM dropped_large)        AS dropped_large_blocks,
    (SELECT COALESCE(MAX(n), 0) FROM block_sizes) AS max_block_size_observed,
    (SELECT COALESCE(AVG(n)::DOUBLE, 0) FROM kept_blocks) AS avg_block_size_kept,
    (SELECT COALESCE(quantile_cont(n, 0.90), 0) FROM kept_blocks) AS p90_block_size_kept,
    (SELECT COALESCE(SUM(est_pairs), 0) FROM pair_estimates) AS est_pairs_total
    {% if pairs_table is defined and pairs_table %}
    , (SELECT COUNT(*) FROM {{ pairs_table }}) AS actual_pairs_total
    {% endif %}
)

-- 1) save all block sizes (handy to inspect heavy blocks)
CREATE OR REPLACE TABLE {{ target_schema }}.blocking_block_sizes AS
SELECT * FROM block_sizes;

-- 2) overall one-row summary
CREATE OR REPLACE TABLE {{ target_schema }}.blocking_stats AS
SELECT * FROM overall;

-- 3) by-kind summary (counts & estimates)
CREATE OR REPLACE TABLE {{ target_schema }}.blocking_stats_by_kind AS
SELECT
  bs.kind,
  COUNT(*)                                     AS blocks_total,
  SUM(CASE WHEN bs.n BETWEEN 2 AND {{ max_block_size }} THEN 1 ELSE 0 END) AS blocks_kept,
  SUM(CASE WHEN bs.n < 2 THEN 1 ELSE 0 END)    AS blocks_dropped_small,
  SUM(CASE WHEN bs.n > {{ max_block_size }} THEN 1 ELSE 0 END) AS blocks_dropped_large,
  COALESCE(SUM(CASE WHEN bs.n BETWEEN 2 AND {{ max_block_size }} THEN (bs.n * (bs.n - 1)) / 2 ELSE 0 END),0)::BIGINT AS est_pairs
  {% if pairs_table is defined and pairs_table %}
  , NULL AS actual_pairs  -- optional: compute per-kind only if pairs table carries kind info
  {% endif %}
FROM block_sizes bs
GROUP BY bs.kind;

-- 4) (optional) a quick view of top heavy kept blocks
CREATE OR REPLACE VIEW {{ target_schema }}.blocking_top_blocks AS
SELECT kind, bkey, n
FROM kept_blocks
ORDER BY n DESC
LIMIT 100;