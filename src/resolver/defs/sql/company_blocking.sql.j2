-- This creates blocks and pairs - will likely blow out memory

-- blocking_pairs.sql.j2
-- Parameters you can pass when rendering:
--   source_table      : e.g. silver.companies
--   target_schema     : e.g. er
--   target_table      : e.g. blocking_pairs
--   id_col            : 'company_id'
--   name_col          : 'company_name'
--   domain_col        : 'domain_name'
--   city_col          : 'city'
--   country_col       : 'final_country'
--   max_block_size    : e.g. 1000
--   use_domain        : true/false
--   use_name3_country : true/false
--   use_compact5_city : true/false

CREATE SCHEMA IF NOT EXISTS {{ target_schema }};

CREATE OR REPLACE TABLE {{ target_schema }}.{{ target_table }} AS
WITH base AS (
  SELECT
    {{ id_col }}::BIGINT                           AS company_id,
    NULLIF(LOWER(TRIM({{ domain_col }})), '')      AS domain_name,
    -- normalize name: lower, strip non-alnum, collapse whitespace, make a compact variant
    LOWER({{ name_col }})                          AS name_lower,
    REGEXP_REPLACE(LOWER({{ name_col }}), '[^a-z0-9\s]', '', 'g')         AS name_alnum,
    REGEXP_REPLACE(REGEXP_REPLACE(LOWER({{ name_col }}), '[^a-z0-9\s]', '', 'g'), '\s', '', 'g') AS name_compact,
    NULLIF(LOWER(TRIM({{ city_col }})), '')        AS city,
    NULLIF(LOWER(TRIM({{ country_col }})), '')     AS country
  FROM {{ source_table }}
),

blocks AS (
  {% set first = true %}

  {% if use_domain %}
  SELECT company_id, 'domain' AS kind, domain_name AS bkey
  FROM base
  WHERE domain_name IS NOT NULL
  {% set first = false %}
  {% endif %}

  {% if use_name3_country %}
  {% if not first %} UNION ALL {% endif %}
  SELECT company_id, 'name3_country' AS kind,
         CONCAT(SUBSTR(name_compact, 1, 3), '|', country) AS bkey
  FROM base
  WHERE name_compact IS NOT NULL AND country IS NOT NULL AND LENGTH(name_compact) >= 3
  {% set first = false %}
  {% endif %}

  {% if use_compact5_city %}
  {% if not first %} UNION ALL {% endif %}
  SELECT company_id, 'compact5_city' AS kind,
         CONCAT(SUBSTR(name_compact, 1, 5), '|', city) AS bkey
  FROM base
  WHERE name_compact IS NOT NULL AND city IS NOT NULL AND LENGTH(name_compact) >= 5
  {% endif %}
),

-- keep only blocks with 2..max_block_size members to avoid combinatorial explosions
valid_blocks AS (
  SELECT kind, bkey
  FROM blocks
  GROUP BY kind, bkey
  HAVING COUNT(*) BETWEEN 2 AND {{ max_block_size }}
),

pairs_raw AS (
  SELECT
    a.company_id AS company_id_a,
    b.company_id AS company_id_b,
    a.kind       AS kind
  FROM blocks a
  JOIN valid_blocks vb
    ON a.kind = vb.kind AND a.bkey = vb.bkey
  JOIN blocks b
    ON b.kind = a.kind AND b.bkey = a.bkey
   AND b.company_id > a.company_id           -- enforce A < B to avoid dup direction
),

-- de-dupe across multiple block kinds but keep provenance of which kinds matched
pairs AS (
  SELECT
    company_id_a,
    company_id_b,
    STRING_AGG(DISTINCT kind, ',') AS kinds_matched
  FROM pairs_raw
  GROUP BY company_id_a, company_id_b
)

SELECT company_id_a, company_id_b, kinds_matched
FROM pairs
ORDER BY 1, 2;